// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"9P7y/wcAAP//GTf/1f/WAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
