// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"kJun2QAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
