// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information for the creator of an asset or application.
	// (GET /v2/accounts/creator/{ident})
	AccountInformationCreatorOf(ctx echo.Context, ident uint64, params AccountInformationCreatorOfParams) error
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformationCreatorOf converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformationCreatorOf(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "ident" -------------
	var ident uint64

	err = runtime.BindStyledParameter("simple", false, "ident", ctx.Param("ident"), &ident)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ident: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationCreatorOfParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformationCreatorOf(ctx, ident, params)
	return err
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/creator/:ident", wrapper.AccountInformationCreatorOf, m...)
	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/dryrun", wrapper.TransactionDryRun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
